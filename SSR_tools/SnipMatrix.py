#!/usr/bin/python
#SnipMatrix  09-2019
#Written by Joseph Sarro
#This script inputs a matrix generated by the GapGenes script and edits it. Each contig will contian a maximum of 3 SSRs, They will have 4 or more reads, and they will not be less than 25% the most abundant SSR. 
from __future__ import division
import numpy as np
import os
import argparse
from operator import itemgetter
#note: Enter a SAM file in the command line and make sure the bait info file matches the one below
samplename =' '
parser = argparse.ArgumentParser(description='Format a matrix generated by GapGenes.')
parser.add_argument('mat', type=str,help='Enter a matrix file')
args = parser.parse_args()
samplename= args.mat
#format the file to make sure tab spacing it correct
os.system("sed -i -e  's/\s\+/\t/g' "+samplename)
os.system("sed -i -e  's/\s\+\t/\t/g' "+samplename)
os.system("sed -i -e  's/\t\+/\t/g' "+samplename)
f = open(samplename, 'r')
G= open(samplename+'.trimmed.txt','w')
#define sort command
def sortSecond(val):
	return val[1]
#read in header file to save and print species names later
line = f.readline()
field=line.split("	")
#print field
print >> G, field[0],"	",field[1].rstrip("\n")
#after printing header go through each line in file
for lines in f:
	#set contig from first column. Second column contians comma deliminated list of SSRws
	fields = lines.split("	")
	contig=fields[0]
	ssr=fields[1]
	arr=[]
	largest=0
	count=1
	fill =False
	for ssrs in ssr.split(','):
    		#print ssrs.rstrip("\n") 
		s = ssrs.rstrip("\n").split("(")
		#print s
		length=int(s[0])
		read_count=int(s[1].rstrip(")"))
		#do not keep SSR with less then 4 reads
		if int(read_count) >=4:
			arr.append([length,read_count])
			fill=True #there is something in the array
			#if int(read_count) > int(largest):
			#	largest=read_count
			#	arr.append([length,read_count])
			#elif int(read_count)/int(largest) >= .25:
			#	arr.append([length,read_count])
	#print arr
	#arrs = sorted(arr,key=lambda l:l[1], reverse=True)
	#print "---------"
	#arr.sort(key=lambda arr:arr[1])
	#arrs = sorted(arr, key=lambda x: (x.__getitem__(1))
	#arrs=sorted(arr,key=lambda x: x[1])
	#arrs=sorted(arr,key=itemgetter(1))
	arr.sort(key = sortSecond, reverse = True)
	#print arr
	#print arr([0,1])
	#print[row[1] for row in arr]
	#print arr.sort(key=lambda x:x[1])
	#if array is not empty print first SSR and then loop through array
	if fill==True:
		print >> G, fields[0],"	",arr[0][0],"(",arr[0][1],")",
		#l=arr[0][0]
		r=arr[0][1]
		#print l,"(",r,")"
		largest=int(r)
		#nxt=int(arr[count][1])
		listlen=len(arr)
		while count < listlen:
			nxt=int(arr[count][1])
			#print count
		#for i in arr:
			#Print SSR if there are not yet 3 and if its ratio is a match
			if count <3 and nxt/largest >= .25:
				#print count
				#print nxt
				#print largest
				#print nxt/largest
				print >> G,",",arr[count][0],"(",arr[count][1],")",
				#print arr[count][0],"(",arr[count][1],")"
				count +=1
			#elif count <2 and nxt/largest >= .25 and count == (listlen-1):
			#	print >> G,",",arr[count][0],"(",arr[count][1],")"
                         #       count +=1
			#elif count==2 and nxt/largest >= .25:
			#	print >> G,",",arr[count][0],"(",arr[count][1],")"
			#	count +=1
			#	break
			else:
				#print arr[count][0],"(",arr[count][1],")"
				#print >> G
				break
		#print end of line for next contig
		print >> G
f.close()
G.close()
#sed commands to format the matrix
os.system("sed -i -e  's/\s(\s/(/g' "+samplename+".trimmed.txt")
os.system("sed -i -e  's/\s)\s,\s/),/g' "+samplename+".trimmed.txt")
os.system("sed -i -e  's/\s)/)/g' "+samplename+".trimmed.txt")
#os.system("sed -i -e  '/^$\|0 ( 0)/d' "+samplename+".Matrix.txt")
#os.system("sed -i -e  's/,\n/\r/g' Matrix.txt")
